{"pageProps":{"post":{"id":"2022-05-12-backend-power-on-self-test","meta":{"title":"Backend Services: Power-on Self-test","date":"2022-05-12","coverImage":"https://images.unsplash.com/photo-1458007683879-47560d7e33c3?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1920&q=80","coverImageCaption":"Photo by [Thomas Kelley](https://unsplash.com/@thkelley) on Unsplash","tags":["webapp","fault-tolerance","backend"]},"content":"\nBackend services are the procesing blocks that empower the logic of an application served well. They do all sorts of things: talk to databases, keep things in caches, process data from message queues, serve webhooks for external systems, process images, or even send push notifications to users' mobile devices - indispensible part to a well designed software architecture, whether for a web or mobile app.\n\nTo make services more reusable and being able to change behaviour without changing code, configuration parameters are typically provided to tell the services what kind of environment it is operating in. For example:\n\n- `NODE_ENV=production`: to inform that a service is running in production environment\n- `DB_HOST, DB_PORT`: which database server to connect to\n- `DB_USERNAME, DB_PASSWORD`: what user account to use when talking to database\n- `JWT_SECRET`: what JWT shared secret to use\n- `REQ_TIMEOUT_LIMIT=5000`: what timeout in milliseconds to use when sending requests to other services\n\nSometimes backend services deployment fail way past deployment because of misconfiguration. It is possible to enter the wrong `DB_HOST` hostname, missed out on setting the value for `JWT_SECRET` or even have a typo in the key or value of any configuration parameters. As services grow larger, we tend not to encounter these errors early on until the particular section of code gets executed under some specific conditions.\n\nFor example, if your database connection uses lazy loading and/or connection pooling, chances are that your backend service doesn't establish a connection to the database at start up (or shortly after deployment) until it is needed while serving some request much later.\n\n> We end up celebrating too early at a successful deployment only to find the services failing when it starts serving workload.\n\n## Enter Power-on Self-test\n\nIn the world of hardware and embedded systems, it is typical for engineers to embed a set of self-testing routines called [Power-on Self-test](https://en.wikipedia.org/wiki/Power-on_self-test) (POST). Simply put, when the system starts up\n\nPower-on Self-test is much more common than we know it. They are commonly found in\n\n- airplanes\n- medical equipment\n- computers\n- phones\n- gaming consoles\n- TVs\n\n> Can you imagine yourself in a plane up in the air, only to find the plane stalling mid-air because of fuel amount was in reserves during take-off?\n\nCould the plane's software system checked on the amount of fuel remaining before allowing the pilot to start the engine?\n\nLikewise, to build resilient backend services, it's important to include some form of POST routine at service pre-initialization. By allowing backend services to fail early on shortly after deployment, services wouldn't fail while serving requests or processing important data.\n\nIn an Express.js HTTP API service, I'd write a POST routine like this:\n\n```typescript\n// post.ts\n\n/// .... imports goes here\n\nconst { JWT_SECRET } = process.env;\n\nexport async function powerOnSelfTest() {\n  // check if JWT secret was configured and can be used to sign and verify payload\n  assert(JWT_SECRET);\n  const token = jwt.sign(\"testData\", JWT_SECRET);\n  const payload = jwt.verify(token, JWT_SECRET);\n  assert(payload === \"testData\");\n\n  // check if database connection and credentials are OK\n  const dbConn = createDbConnection();\n  try {\n    await dbConn.authenticate();\n  } catch (e) {\n    console.error(\"Error connecting to DB\", e);\n    throw e;\n  }\n}\n```\n\nBefore starting up the HTTP listener, I'd run the POST routine:\n\n```typescript\n// index.ts\n\n/// .... other imports\nimport { powerOnSelfTest } from \"./post\";\n\nasync function startApp() {\n  const app = express();\n\n  const db = await initDbModels(createDbConnection());\n  app.locals.db = db;\n\n  /// ... setup routes\n\n  const port = process.env.PORT || 3333;\n  const server = app.listen(port, () => {\n    console.log(`Listening at port ${port}`);\n  });\n}\n\n// start up the application\npowerOnSelfTest()\n  .then(startApp)\n  // catch POST and startup errors here\n  .catch((err) => console.error(err));\n```\n\nEven if all the environment variables provided to the application were correct, the POST routine would at least check for connectivity between the service and dependent servers like the database. Problems like version incompatibility, network connectivity or incorrect infrastructure setup, can also be caught in the POST - _at very little cost_.\n\nHaving POST routines in place, I can be _slightly more_ confident that my backend services would work beyond post-deployment.\n\nPOST routines work as well as they are written. As [Edsger W. Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) puts it, POST routines - like any other tests - can only prove the presence, **not** the absence of bugs. You can instead embrace POST routines as another hammer in your toolbox in catching catch potential failures early on.\n","prevId":"2022-05-08-react-query-options"},"prevPost":{"id":"2022-05-08-react-query-options","meta":{"title":"React-Query: abstracting query options","date":"2022-05-08","coverImage":"https://images.unsplash.com/photo-1515674447568-09bbb507b96c?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&dl=possessed-photography-Xlx80tr5bEE-unsplash.jpg&w=1920","coverImageCaption":"Photo by [Possessed Photography](https://unsplash.com/@possessedphotography) on Unsplash","tags":["react","react-query"]},"content":"\nI've found [react-query](https://react-query.tanstack.com/) to be pleasantly straightforward and easy to use in managing server-side state on React and React Native apps, with plenty of support and resources from the likes of [TkDodo's blog](https://tkdodo.eu/blog/practical-react-query) and [online courses](https://ui.dev/react-query?coupon_code=aQcnd).\n\nReact Query deals with, you guessed it, [queries](https://react-query.tanstack.com/guides/queries). As you build up your React application, you will find yourself facing some of these scenarios:\n\n- you have queries that execute depending on the data returned from an earlier query: you can run conditional queries like in the guide on [Dependent Queries](https://react-query.tanstack.com/guides/dependent-queries).\n- you have queries that can run in parallel: [`useQueries()`](https://react-query.tanstack.com/guides/parallel-queries) is there to solve parallel queries\n- you have the same query that will be requested by multiple components in the same render cycle: It's more favourable to request for the same query multiple times than to perform [props drilling](https://blogs.perficient.com/2021/12/03/understanding-react-context-and-property-prop-drilling/), as you can configure [`staleTime`](https://react-query.tanstack.com/guides/important-defaults) to your needs\n\nTkDodo has written about [creating custom hooks](https://tkdodo.eu/blog/practical-react-query#create-custom-hooks). Using custom hooks makes reading a component's code a breeze, because `useQuery` and how data is fetched gets colocated together in a custom hook. For example, a custom hook to fetch the list of todo items:\n\n```typescript\nexport const useTodoListQuery = (filter: Filter = {}) =>\n  useQuery([\"todos\", filter], () => fetchTodoList(filter));\n```\n\nAs I encountered more of those scenarios I described earlier, I found the need to reuse queries written in `useQuery` to also be used in `useQueries` for parallel execution. To make things more manageable, I decided to write utility function for constructing query options:\n\n```typescript\nexport const buildTodoListQueryOptions = (filter: Filter) => ({\n  queryKey: [\"todos\", filter],\n  queryFn: () => fetchTodoList(filter),\n});\n\nexport const useTodoListQuery = (filter: Filter = {}) =>\n  useQuery(buildTodoListQueryOptions(filter));\n```\n\nIn the event that I need to build a portion of User Interface that needed to run the `useTodoListQuery` in parallel with something else, say loading calendar items, I can do this:\n\n```typescript\nexport const buildTodoListQueryOptions = (filter: Filter) => ({\n  // ...\n});\n\nexport const useTodoListQuery = // ...\n\nexport const buildCalendarItemsQueryOptions = (dateRange: DateRange) => ({\n  queryKey: [\"calendar\", dateRange],\n  queryFn: () => fetchCalendarItems(dateRange),\n});\n\nexport const useCalendarItemsQuery = // ...\n\nexport const useLandingInfoQuery = (\n  dateRange: DateRange,\n  filter: Filter = {}\n) =>\n  useQueries([\n    buildCalendarItemsQueryOptions(dateRange),\n    buildTodoListQueryOptions(filter),\n  ]);\n```\n\nThis makes it easier to build composable queries. That said, I don't think everyone should start going around and pick out their query options from whereever `useQuery` appeared. The abstraction should only occur when there is a good enough reason to do so, like when a particular query needs to be used in multiple instances of `useQuery` and `useQueries` to enhance user experience and loading time.\n\nWhat do you think?\n","nextId":"2022-05-12-backend-power-on-self-test","prevId":"2022-04-11-giscus-blog-comments-github-discussions"}},"__N_SSG":true}