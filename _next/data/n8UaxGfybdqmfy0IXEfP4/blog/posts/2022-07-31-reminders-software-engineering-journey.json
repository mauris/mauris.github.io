{"pageProps":{"post":{"id":"2022-07-31-reminders-software-engineering-journey","meta":{"title":"3 reminders when starting a Software Engineering journey","date":"2022-07-31","coverImage":"https://images.unsplash.com/photo-1656444698971-5eed37d977c7?ixlib=rb-1.2.1&dl=meagan-feddersen-AYKuGNzWJns-unsplash.jpg&w=1920&q=80&fm=jpg&crop=entropy&cs=tinysrgb","coverImageCaption":"Photo by [Meagan Feddersen](https://unsplash.com/@meaganfedds) on Unsplash","tags":["career","software-engineering"]},"content":"\nStarting a new software engineering role can get a little overwhelming at a new place. As I navigated through my new role in the past months, I was reminded that as much as I observe the work culture, processes and team in my new position, I'm more of a participant than an observer.\n\nThese are 3 things that can be of helpful reminder for anyone starting out.\n\n## 1. Ask questions, often\n\nWhether it's day 1 or 3 years in, communication is key to alignment and understanding.\n\nIt's often that we don't ask questions out of fear of asking a \"wrong\" or \"stupid\" question, but it shouldn't be the way. I think it is okay to just ask, clarify and understand. That way as you go along, you learn how to ask better questions that can (1) put you and your team on track, (2) navigate you and your team around potential roadblocks, and (3) help you deepen your understanding of the value and meaning of your contribution. \n\nIt's way better to ask a \"wrong\" or \"stupid\" question than to be a muted team member, because being muted no one else will know what you know. Silence doesn't always mean alignment. \n\nIf you find yourself in a place where you're often condemned for asking a \"wrong\" or \"stupid\" questions, you might want to consider if the environment you're in is helping you grow. \n\nYou might want to find out what's a good way to ask your question, whether synchronously in a Zoom call, asynchronously on the meeting chat, in a 1:1 direct message, or asking it in an open space like wiki comments. \n\n## 2. Get involved, early\n\nThere are opportunities for growth for you when you get involved. You get to learn and hone both technical skills and soft skills when you do this.\n\nFor example, as a junior software engineer, if you're assigned a project to build a backend software system, there are several benefits of getting involved early with:\n\n- you can shadow your lead / principal software engineer on the system design and pick up after them on the good stuff\n- you can learn about the problem domain better, what are the business / product requirements, how are they derived etc. in turn this helps provide meaning and context to your contributions\n\n## 3. Close the feedback loop\n\nWords matter, a lot. \n\nAs much as you want to feel appreciated for your work from peers and leads, you can take the first step to thank others every step of the way. For a peer who has gone out of their way to help or guide you, you can:\n\n- Leave a thank you message to appreciate them\n- Treat them to coffee\n\nIt cost nothing to say thanks genuinely and to play a part in building a positive work environment.\n\n<div style=\"width:100%;height:0;padding-bottom:56%;position:relative;\"><iframe src=\"https://giphy.com/embed/xZxtYEV4GHQtgccxIl\" width=\"100%\" height=\"100%\" style=\"position:absolute\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe></div><p><a href=\"https://giphy.com/gifs/TheSwoon-netflix-swoon-theswoon-xZxtYEV4GHQtgccxIl\">via GIPHY</a></p>\n\nAll the best in your journey too. Check out the additional resources:\n\n- [Top 10 pieces of advice for rookie software engineers](https://medium.com/singapore-gds/top-10-pieces-of-advice-for-rookie-software-engineer-f1a2b38f1d56)","prevId":"2022-05-12-backend-power-on-self-test"},"prevPost":{"id":"2022-05-12-backend-power-on-self-test","meta":{"title":"Backend Services: Power-on Self-test","date":"2022-05-12","coverImage":"https://images.unsplash.com/photo-1458007683879-47560d7e33c3?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1920&q=80","coverImageCaption":"Photo by [Thomas Kelley](https://unsplash.com/@thkelley) on Unsplash","tags":["webapp","fault-tolerance","backend"]},"content":"\nBackend services are the procesing blocks that empower the logic of an application served well. They do all sorts of things: talk to databases, keep things in caches, process data from message queues, serve webhooks for external systems, process images, or even send push notifications to users' mobile devices - indispensible part to a well designed software architecture, whether for a web or mobile app.\n\nTo make services more reusable and being able to change behaviour without changing code, configuration parameters are typically provided to tell the services what kind of environment it is operating in. For example:\n\n- `NODE_ENV=production`: to inform that a service is running in production environment\n- `DB_HOST, DB_PORT`: which database server to connect to\n- `DB_USERNAME, DB_PASSWORD`: what user account to use when talking to database\n- `JWT_SECRET`: what JWT shared secret to use\n- `REQ_TIMEOUT_LIMIT=5000`: what timeout in milliseconds to use when sending requests to other services\n\nSometimes backend services deployment fail way past deployment because of misconfiguration. It is possible to enter the wrong `DB_HOST` hostname, missed out on setting the value for `JWT_SECRET` or even have a typo in the key or value of any configuration parameters. As services grow larger, we tend not to encounter these errors early on until the particular section of code gets executed under some specific conditions.\n\nFor example, if your database connection uses lazy loading and/or connection pooling, chances are that your backend service doesn't establish a connection to the database at start up (or shortly after deployment) until it is needed while serving some request much later.\n\n> We end up celebrating too early at a successful deployment only to find the services failing while handling workload.\n\n## Enter Power-on Self-test\n\nIn the world of hardware and embedded systems, it is typical for engineers to embed a set of self-testing routines called [Power-on Self-test](https://en.wikipedia.org/wiki/Power-on_self-test) (POST). Simply put, when the system starts up\n\nPower-on Self-test is much more common than we know it. They are commonly found in\n\n- airplanes\n- medical equipment\n- computers\n- phones\n- gaming consoles\n- TVs\n\n> Can you imagine yourself in a plane up in the air, only to find the plane stalling mid-air because of fuel amount was in reserves during take-off?\n\nCould the plane's software system checked on the amount of fuel remaining before allowing the pilot to start the engine?\n\nLikewise, to build resilient backend services, it's important to include some form of POST routine at service pre-initialization. By allowing backend services to fail early on shortly after deployment, services wouldn't fail while serving requests or processing important data.\n\nIn an Express.js HTTP API service, I'd write a POST routine like this:\n\n```typescript\n// post.ts\n\n/// .... imports goes here\n\nconst { JWT_SECRET } = process.env;\n\nexport async function powerOnSelfTest() {\n  // check if JWT secret was configured and can be used to sign and verify payload\n  assert(JWT_SECRET);\n  const token = jwt.sign(\"testData\", JWT_SECRET);\n  const payload = jwt.verify(token, JWT_SECRET);\n  assert(payload === \"testData\");\n\n  // check if database connection and credentials are OK\n  const dbConn = createDbConnection();\n  try {\n    await dbConn.authenticate();\n  } catch (e) {\n    console.error(\"Error connecting to DB\", e);\n    throw e;\n  }\n}\n```\n\nBefore starting up the HTTP listener, I'd run the POST routine:\n\n```typescript\n// index.ts\n\n/// .... other imports\nimport { powerOnSelfTest } from \"./post\";\n\nasync function startApp() {\n  const app = express();\n\n  const db = await initDbModels(createDbConnection());\n  app.locals.db = db;\n\n  /// ... setup routes\n\n  const port = process.env.PORT || 3333;\n  const server = app.listen(port, () => {\n    console.log(`Listening at port ${port}`);\n  });\n}\n\n// start up the application\npowerOnSelfTest()\n  .then(startApp)\n  // catch POST and startup errors here\n  .catch((err) => console.error(err));\n```\n\nEven if all the environment variables provided to the application were correct, the POST routine would at least check for connectivity between the service and dependent servers like the database. Problems like version incompatibility, network connectivity or incorrect infrastructure setup, can also be caught in the POST - _at very little cost_.\n\nHaving POST routines in place, I can be _slightly more_ confident that my backend services would work beyond post-deployment.\n\nPOST routines work as well as they are written. As [Edsger W. Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) puts it, POST routines - like any other tests - can only prove the presence, **not** the absence of bugs. You can instead embrace POST routines as another hammer in your toolbox in catching catch potential failures early on.\n","nextId":"2022-07-31-reminders-software-engineering-journey","prevId":"2022-05-08-react-query-options"}},"__N_SSG":true}