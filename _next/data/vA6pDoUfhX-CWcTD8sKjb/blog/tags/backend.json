{"pageProps":{"posts":[{"id":"2022-05-12-backend-power-on-self-test","meta":{"title":"Backend Services: Power-on Self-test","date":"2022-05-12","coverImage":"https://images.unsplash.com/photo-1458007683879-47560d7e33c3?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1920&q=80","coverImageCaption":"Photo by [Thomas Kelley](https://unsplash.com/@thkelley) on Unsplash","tags":["webapp","fault-tolerance","backend"]},"content":"\nBackend services are the procesing blocks that empower the logic of an application served well. They do all sorts of things: talk to databases, keep things in caches, process data from message queues, serve webhooks for external systems, process images, or even send push notifications to users' mobile devices - indispensible part to a well designed software architecture, whether for a web or mobile app.\n\nTo make services more reusable and being able to change behaviour without changing code, configuration parameters are typically provided to tell the services what kind of environment it is operating in. For example:\n\n- `NODE_ENV=production`: to inform that a service is running in production environment\n- `DB_HOST, DB_PORT`: which database server to connect to\n- `DB_USERNAME, DB_PASSWORD`: what user account to use when talking to database\n- `JWT_SECRET`: what JWT shared secret to use\n- `REQ_TIMEOUT_LIMIT=5000`: what timeout in milliseconds to use when sending requests to other services\n\nSometimes backend services deployment fail way past deployment because of misconfiguration. It is possible to enter the wrong `DB_HOST` hostname, missed out on setting the value for `JWT_SECRET` or even have a typo in the key or value of any configuration parameters. As services grow larger, we tend not to encounter these errors early on until the particular section of code gets executed under some specific conditions.\n\nFor example, if your database connection uses lazy loading and/or connection pooling, chances are that your backend service doesn't establish a connection to the database at start up (or shortly after deployment) until it is needed while serving some request much later.\n\n> We end up celebrating too early at a successful deployment only to find the services failing when it starts serving workload.\n\n## Enter Power-on Self-test\n\nIn the world of hardware and embedded systems, it is typical for engineers to embed a set of self-testing routines called [Power-on Self-test](https://en.wikipedia.org/wiki/Power-on_self-test) (POST). Simply put, when the system starts up\n\nPower-on Self-test is much more common than we know it. They are commonly found in\n\n- airplanes\n- medical equipment\n- computers\n- phones\n- gaming consoles\n- TVs\n\n> Can you imagine yourself in a plane up in the air, only to find the plane stalling mid-air because of fuel amount was in reserves during take-off?\n\nCould the plane's software system checked on the amount of fuel remaining before allowing the pilot to start the engine?\n\nLikewise, to build resilient backend services, it's important to include some form of POST routine at service pre-initialization. By allowing backend services to fail early on shortly after deployment, services wouldn't fail while serving requests or processing important data.\n\nIn an Express.js HTTP API service, I'd write a POST routine like this:\n\n```typescript\n// post.ts\n\n/// .... imports goes here\n\nconst { JWT_SECRET } = process.env;\n\nexport async function powerOnSelfTest() {\n  // check if JWT secret was configured and can be used to sign and verify payload\n  assert(JWT_SECRET);\n  const token = jwt.sign(\"testData\", JWT_SECRET);\n  const payload = jwt.verify(token, JWT_SECRET);\n  assert(payload === \"testData\");\n\n  // check if database connection and credentials are OK\n  const dbConn = createDbConnection();\n  try {\n    await dbConn.authenticate();\n  } catch (e) {\n    console.error(\"Error connecting to DB\", e);\n    throw e;\n  }\n}\n```\n\nBefore starting up the HTTP listener, I'd run the POST routine:\n\n```typescript\n// index.ts\n\n/// .... other imports\nimport { powerOnSelfTest } from \"./post\";\n\nasync function startApp() {\n  const app = express();\n\n  const db = await initDbModels(createDbConnection());\n  app.locals.db = db;\n\n  /// ... setup routes\n\n  const port = process.env.PORT || 3333;\n  const server = app.listen(port, () => {\n    console.log(`Listening at port ${port}`);\n  });\n}\n\n// start up the application\npowerOnSelfTest()\n  .then(startApp)\n  // catch POST and startup errors here\n  .catch((err) => console.error(err));\n```\n\nEven if all the environment variables provided to the application were correct, the POST routine would at least check for connectivity between the service and dependent servers like the database. Problems like version incompatibility, network connectivity or incorrect infrastructure setup, can also be caught in the POST - _at very little cost_.\n\nHaving POST routines in place, I can be _slightly more_ confident that my backend services would work beyond post-deployment.\n\nPOST routines work as well as they are written. As Edsger W. Dijkstra puts it, POST routines - like any other tests - can prove the presence of bugs, **not** the absence of bugs. Instead, you can see POST routines as an additional tool to catch potential failures early on and thus building services that are more resilient.\n","prevId":"2022-05-08-react-query-options"}],"tag":"backend"},"__N_SSG":true}